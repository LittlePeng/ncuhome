2011-10-10
是想我们应该用尽小量的修改完成异步操作，保证同步方式还是不做任何代码修改，只添加部分异步实现代码
保证不对现有逻辑带入Bug

为什么用异步：
主要是DB慢时线程可能占用太多，线程池管理太多线程导致性能下降

线程池限制：
这个还是继续有，而且如果工作连接超过最大值时，还是采用阻塞的方式。因为DB不同于RPC，请求越多可能越慢，同时
mysql采用连接和线程一对一方式，连接太多占用资源太多不说，可能造成吞吐量下降


何时采用异步：
与mysql在网络上的交互用很多：ping，show，statement prepared・・・，大多才做不用IO，可以很及时的应答。
现在我们只对有ResultSet的请求做异步。
通过比较简单的方式，发送DB查询 《---》结果集应答，两者之间通过Socket的IOCP实现异步方式。
通过BeginRecevie，buffer的length设置为0，BeginRecevie不读取流中任何数据，只是当结果集一开始返回时，便开始转回同步方式
因为DB结果集都已经完成了，异步传输没有必要了

2011-10-11
干，终于条完了功能，性能一测试，TN为什么线程数量没有下降呢？？

2000-10-11
windbg查看线程栈，线程都是在Socket.Receive，这是在干嘛？应该不是这个方法吧
----------------
终于发现原来是BufferStream包装NetWorkStream造成的问题，那么的BeginRead的时候直接使用NetWorkStream解决该问题：）


TODO：
1.超时，还没做，貌似以前的就有问题啊・・・
2.存储过程参数缓存，因为修改参数后需要重启服务解决，定时刷？缓存数量貌似也少了点啊
3.连接池回收
4.