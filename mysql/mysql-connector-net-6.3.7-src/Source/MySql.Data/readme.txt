2011-10-10
是想我们应该用尽小量的修改完成异步操作，保证同步方式还是不做任何代码修改，只添加部分异步实现代码
保证不对现有逻辑带入Bug

为什么用异步：
主要是DB慢时线程可能占用太多，线程池管理太多线程导致性能下降

线程池限制：
这个还是继续有，而且如果工作连接超过最大值时，还是采用阻塞的方式。因为DB不同于RPC，请求越多可能越慢，同时
mysql采用连接和线程一对一方式，连接太多占用资源太多不说，可能造成吞吐量下降


何时采用异步：
与mysql在网络上的交互用很多：ping，show，statement prepared・・・，大多才做不用IO，可以很及时的应答。
现在我们只对有ResultSet的请求做异步。
通过比较简单的方式，发送DB查询 《---》结果集应答，两者之间通过Socket的IOCP实现异步方式。
通过BeginRecevie，buffer的length设置为0，BeginRecevie不读取流中任何数据，只是当结果集一开始返回时，便开始转回同步方式
因为DB结果集都已经完成了，异步传输没有必要了

2011-10-11
干，终于条完了功能，性能一测试，TN为什么线程数量没有下降呢？？

2000-10-11
windbg查看线程栈，线程都是在Socket.Receive，这是在干嘛？应该不是这个方法吧
----------------
终于发现原来是BufferStream包装NetWorkStream造成的问题，那么的BeginRead的时候直接使用NetWorkStream解决该问题：）

2011-10-13
修改Timeout实现，但是，Kill之后返回的是OK Packet，而不是Error Packet，应该原来实现就有问题的。

而且connection被关闭了??
2011-10-26
添加清理机制，参考官方6.2.3做法。每过3分钟执行删除idle超过3分钟 的连接，idle Stack保持最小配置mini pool size（默认为0）

最新版本使用Stream超时处理，很好的解决

TODO：
1.超时，还没做，貌似以前的就有问题啊・・・
2.存储过程参数缓存，因为修改参数后需要重启服务解决，定时刷？缓存数量貌似也少了点啊
3.连接池回收
4.异步连接池和同步池分开？，异步主要用于量大工作，可能造成同步请求拿不到连接问题
---可以使用百分比算，超过百分比 阻塞等待。
--主要是异步等待的话，conection.open就要异步，太麻烦。如果Execute才开始获取connection的话，改动太大吧~


5.添加清理Procudce cache清理功能，现在参数缓存了智能重启服务了

=======================================分割线==========================================================
转到官方6.3.7版本
$/SSV4.X/src_V4.3/reference/mysql-connector-net/mysql-connector-net-6.3.7-src

对于Socket，ReadTimeOut、WriteTimeOut设置对异步方法无效，令人郁闷的还是需要自己做超时处理呢・・